#!/usr/bin/python
# encoding: utf-8
#
# Copyright 2011-2018 Greg Neagle.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
manifestutil

Created by Greg Neagle on 2011-03-04.
"""

# TODO: add support for delete-manifest

import fnmatch
import optparse
import os
import plistlib
import readline
import shlex
import sys

from xml.parsers.expat import ExpatError
import sys
sys.path.append('/usr/local/munki/')
from munkilib import munkirepo
##### subcommand functions #####

class MyOptParseError(Exception):
    '''Exception for our custom option parser'''
    pass


class MyOptParseExit(Exception):
    '''Raised when optparse calls self.exit() so we can handle it instead
    of exiting'''
    pass

def get_manifest(repo, manifest_name):
    '''Gets the contents of a manifest'''
    manifest_ref = os.path.join('manifests', manifest_name)
    try:
        data = repo.get(manifest_ref)
        return plistlib.readPlistFromString(data)
    except munkirepo.RepoError, err:
        print >> sys.stderr, (u'Could not retreive manifest %s: %s'
                              % (manifest_name, unicode(err)))
        return None
    except (IOError, OSError, ExpatError), err:
        print >> sys.stderr, (
            u'Could not read manifest %s: %s' % (manifest_name, unicode(err)))
        return None

class MyOptionParser(optparse.OptionParser):
    '''Custom option parser that overrides the error handler and
    the exit handler so printing help doesn't exit the interactive
    psuedo-shell'''
    def error(self, msg):
        """error(msg : string)

        """
        self.print_usage(sys.stderr)
        raise MyOptParseError('option error: %s' % msg)

    def exit(self, status=0, msg=None):
        if msg:
            sys.stderr.write(msg)
        raise MyOptParseExit



def expand_included_manifests(repo, args):
    '''Prints a manifest, expanding any included manifests.'''

    def manifest_recurser(repo, manifest):
        '''Recursive expansion of included manifests'''
        # No infinite loop checking! Be wary!
        if 'included_manifests' in manifest:
            for (index, item) in enumerate(manifest['included_manifests']):
                included_manifest = get_manifest(repo, item)
                if included_manifest:
                    included_manifest = manifest_recurser(repo, included_manifest)
                manifest['included_manifests'][index] = {
                    item: included_manifest
                }
        return manifest

    parser = MyOptionParser()
    parser.set_usage('''expand-included-manifest MANIFESTNAME
        Prints included manifests in the specified manifest''')
    try:
        _, arguments = parser.parse_args(args)
    except MyOptParseError, errmsg:
        print >> sys.stderr, str(errmsg)
        return 22 # Invalid argument
    except MyOptParseExit:
        return 0

    if len(arguments) != 1:
        parser.print_usage(sys.stderr)
        return 7 # Argument list too long
    manifestname = arguments[0]
    manifest = get_manifest(repo, manifestname)
    if manifest:
        printplist(manifest_recurser(repo, manifest))
    else:
        return 2 # No such file or directory

repo = '/Library/Managed Installs/manifests'
expand_included_manifests(repo,'C02VV2WSHV2R')
# CMD_ARG_DICT = {}

# def main():
#     '''Our main routine'''

#     cmds = {'add-pkg':                   'pkgs',
#             'add-catalog':               'catalogs',
#             'add-included-manifest':     'manifests',
#             'remove-pkg':                'pkgs',
#             'move-install-to-uninstall': 'pkgs',
#             'remove-catalog':            'catalogs',
#             'remove-included-manifest':  'manifests',
#             'list-manifests':            'manifests',
#             'list-catalogs':             'default',
#             'list-catalog-items':        'catalogs',
#             'display-manifest':          'manifests',
#             'expand-included-manifests': 'manifests',
#             'find':                      'default',
#             'new-manifest':              'default',
#             'copy-manifest':             'manifests',
#             'rename-manifest':           'manifests',
#             'refresh-cache':             'default',
#             'exit':                      'default',
#             'help':                      'default',
#             'configure':                 'default',
#             'version':                   'default'
#            }
#     CMD_ARG_DICT['cmds'] = cmds

#     if len(sys.argv) > 1:
#         # some commands or options were passed at the command line
#         cmd = sys.argv[1].lstrip('-')
#         retcode = handle_subcommand(repo, sys.argv[1:])
#         cleanup_and_exit(retcode)
#     else:
#         # if we get here, no options or commands,
#         # so let's enter interactive mode
#         # must have an available repo for interactive mode
#         repo = connect_to_repo()
#         # build the rest of our dict to enable tab completion
#         CMD_ARG_DICT['options'] = {'--manifest': 'manifests',
#                                    '--section':  'sections'}

#         CMD_ARG_DICT['default'] = []
#         CMD_ARG_DICT['sections'] = get_manifest_pkg_sections()
#         CMD_ARG_DICT['manifests'] = get_manifest_names(repo)
#         CMD_ARG_DICT['catalogs'] = get_catalogs(repo)
#         CMD_ARG_DICT['pkgs'] = get_installer_item_names(
#             repo, CMD_ARG_DICT['catalogs'])

#         set_up_tab_completer()
#         print 'Entering interactive mode... (type "help" for commands)'
#         while 1:
#             try:
#                 cmd = raw_input('> ')
#             except (KeyboardInterrupt, EOFError):
#                 # React to Control-C and Control-D
#                 print # so we finish off the raw_input line
#                 cleanup_and_exit(0)
#             args = shlex.split(cmd)
#             handle_subcommand(repo, args)

if __name__ == '__main__':
    main()
